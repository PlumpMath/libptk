extern "C" {
#include "project.h"
}

#include "ptk/psoc/usbio.h"
#include <algorithm>

using namespace std;
using namespace ptk;
using namespace ptk::psoc;

USBEcho ptk::psoc::usb_echo;

#define _USB_NAME_ CONSOLE
/*
 * The functions defined below depend on USBFS component code generated by PSoC
 * Creator. Since the Creator's UI determines the name of the USBFS component
 * and thus the name of all the generated API routines, it's not possible to
 * simply call those routines by name. The USB_(x) macro is used to reference
 * these API names without having to hard-code a reference to a specific component
 * name in the code. All that's required is to define _USB_NAME_ to be the name of
 * the USBFS component as it appears in PSoC Creator.
 *
 * If there's no definition for _USB_NAME_, then these functions can't be compiled.
 */
#if defined(_USB_NAME_)

#define USB_(x) USB_HELPER_(_USB_NAME_,x)
#define USB_HELPER_(x,y) USB_HELPER2_(x,y)
#define USB_HELPER2_(x,y) x##y

static reg8 *get_output_ep_data_ptr(uint8_t ep) {
  assert(ep > 0 && ep < 9);
  uint8 ri = (ep - USB_(_EP1)) << USB_(_EPX_CNTX_ADDR_SHIFT);
  return (reg8 *) (USB_(_ARB_RW1_DR_IND) + ri);
}

static unsigned get_cdc_ep_buffer_size(uint8_t ep) {
  return USB_(_EP)[ep].bufferSize;
}

static unsigned get_ep_byte_count(uint8_t ep) {
  assert(ep > 0 && ep < 9);

  unsigned ri = ((ep - USB_(_EP1)) << USB_(_EPX_CNTX_ADDR_SHIFT));
  unsigned result = (uint8_t) (CY_GET_REG8((reg8 *)(USB_(_SIE_EP1_CNT0_IND) + ri)) & USB_(_EPX_CNT0_MASK));
  result = (result << 8u) | CY_GET_REG8((reg8 *)(USB_(_SIE_EP1_CNT1_IND) + ri));

  // value from hardware register includes 2 bytes for CRC, don't count them
  result -= USB_(_EPX_CNTX_CRC_COUNT);
  return result;
}

static unsigned read_out_ep_data(uint8_t ep, uint8_t *dst, unsigned limit) {
  return USB_(_ReadOutEP)(ep, dst, limit);
}

void usbfs_endpoint_isr(int ep) {
  enter_isr();
  lock_from_isr();

  // USB endpoint directions are always from the host's point of view,
  // so an IN endpoint sends data from the device to the host. An OUT
  // endpoint interrupt occurs when data has already been sent from the host
  // and is waiting in RAM.
  if (ep == USB_(_cdc_data_in_ep)) {
    usb_echo.tx.device_write_isr();
  } else if (ep == USB_(_cdc_data_out_ep)) {
    usb_echo.rx.device_read_isr();
  }

  unlock_from_isr();
  leave_isr();
}

void usbfs_reset_isr() {
  //usb_echo.reset_isr();
}

#endif // defined(_USB_NAME_)

USBInEndpoint::USBInEndpoint() {
}

unsigned USBInEndpoint::read(uint8_t *buffer, unsigned max) {
  return fifo.read(buffer, max);
}

void USBInEndpoint::device_read_isr() {
  // assume lock_from_isr() has already been called

  unsigned bytes_in_endpoint = get_ep_byte_count(ep);
  unsigned space_in_fifo = fifo.write_capacity();
  reg8 *src = get_output_ep_data_ptr(ep);

  // Unfortunately, the way Cypress' code is generated, read_out_ep_data()
  // must be called exactly once after the endpoint contains data. Any data
  // not read in the first call will be discarded. This makes it difficult
  // to copy endpoint data into a ring buffer, since it may take two copy
  // operations to move everything. To get around this, we do the copying
  // ourselves and then make a final "dummy" call to read_out_ep_data() with
  // a length of zero. This call won't actually move any more data, but
  // will reset the endpoint so it can receive more data from the host.

  while ((bytes_in_endpoint > 0) && (space_in_fifo > 0)) {
    unsigned bytes_to_copy = min(bytes_in_endpoint, space_in_fifo);

    uint8_t *dst = &fifo.poke(0);
    for (unsigned i=bytes_to_copy; i; --i) {
      uint8_t ch = CY_GET_REG8(src);
      *dst++ = ch;
    }

    fifo.fake_write(bytes_to_copy);
    bytes_in_endpoint -= bytes_to_copy;

    // recalculate space because the pointers may have wrapped inside the FIFO
    space_in_fifo = fifo.write_capacity();
  }

  uint8 *arbitrary_non_NULL_ptr = (uint8 *) 0xdeadbeef;
  uint16 zero_bytes = 0;

  // NOTE: this code requires manual endpoint memory management
  // as defined in the USBFS device descriptor
  read_out_ep_data(ep, arbitrary_non_NULL_ptr, zero_bytes);

  if (bytes_in_endpoint > 0) {
    // buffer overflow. what to do?
  }

  broadcast_event(not_empty, 0);
  // assume unlock_from_isr() will be called
}

USBOutEndpoint::USBOutEndpoint() {
}

unsigned USBOutEndpoint::write(const uint8_t *buffer, const unsigned len0) {
  unsigned len = len0;
  lock_kernel();
  bool save_unwritten_data = true;

  if (fifo.read_capacity() > 0) {
    // put the new data behind the old
    fifo.write(buffer, len);

    buffer = &fifo.peek(0);
    len = fifo.read_capacity();

    // if there's data left over later, remember that it's already saved
    save_unwritten_data = false;
  }

  if (CONSOLE_GetEPState(ep) == CONSOLE_IN_BUFFER_EMPTY) {
    // send as much as we can
    unsigned bytes_to_copy = min(get_cdc_ep_buffer_size(ep), len);
    CONSOLE_LoadInEP(ep, buffer, bytes_to_copy);
    buffer += bytes_to_copy;
    len -= bytes_to_copy;
  }

  if ((len > 0) && save_unwritten_data) {
    len -= fifo.write(buffer, len);
  }

  if (len > 0) {
    // buffer overflow. what to do?
  }

  unlock_kernel();

  return len0 - len;
}

void USBOutEndpoint::device_write_isr() {
  // assume lock_from_isr() has been called

  unsigned bytes_in_fifo = fifo.read_capacity();
  if (bytes_in_fifo > 0) {
    unsigned bytes_to_copy = min(get_cdc_ep_buffer_size(ep), bytes_in_fifo);
    CONSOLE_LoadInEP(ep, &fifo.peek(0), bytes_to_copy);
    fifo.fake_read(bytes_to_copy);

    broadcast_event(not_full, 0);
  }
  // assume unlock_from_isr() will be called
}

USBEcho::USBEcho() {
}

#if defined(_USB_NAME_)

void USBEcho::run() {
  PTK_BEGIN();

  // initialize the USB device
  USB_(_Start)(0, USB_(_3V_OPERATION));
  // wait until it's enumerated on the USB bus
  PTK_WAIT_UNTIL(USB_(_GetConfiguration)(), TIME_INFINITE);
  USB_(_CDC_Init)();

  rx.ep = USB_(_cdc_data_out_ep);
  tx.ep = USB_(_cdc_data_in_ep);

  assert(rx.ep == 3);
  assert(tx.ep == 2);

  USB_(_EnableOutEP)(rx.ep);

  while (1) {
    PTK_WAIT_EVENT(rx.not_empty, TIME_INFINITE);

    unsigned bytes_copied;
    do {
      uint8_t buf[8];

      bytes_copied = rx.read(buf, sizeof(buf));
      tx.write(buf, bytes_copied);
    } while (bytes_copied > 0);
  }
  PTK_END();

#endif // defined(_USB_NAME_)
}
